#include "Engine.h"
#include "Cube.h"
#include "DrawState.h"
#include "Camera.h"
#include "Shader.h"
#include <string>

namespace thepit
{
    GlobalState_t GlobalState;

	int global_argc = 0;
	char** global_argv = nullptr;
}

void thepit::Init()
{
    sg_desc setup = {};
    setup.environment = sglue_environment();
    setup.logger.func = slog_func;
    sg_setup(&setup);

    GeometryT* cube = InitNewCubeColorGeometry();

    GlobalState.texcube_geometry = InitNewCubeTexGeometry();
    GlobalState.tex_drawstate = InitNewTexturePipeline();
    GlobalState.colcube_geometry = cube;
    GlobalState.col_drawstate = InitNewColorPipeline();

    ColorT red_color = { 1.0f, 0.0f, 0.0f, 1.0f };
    GlobalState.singlecolorcube = InitNewCubeSingleColorGeometry(red_color);
}

enum struct DrawPassType
{
    DRAWPASS_COLOR,
    DRAWPASS_SINGLECOLOR,
    DRAWPASS_TEXTURE,
    DRAWPASS_NUM
};
static DrawPassType curr_drawpass = DrawPassType::DRAWPASS_COLOR;

void thepit::Frame()
{
    const HMM_Vec3 Origin{ 0.0f, 0.0f, 0.0f };
    const HMM_Vec3 CamPos{ 0.0f, 1.5f, 5.0f };
    const HMM_Vec3 UnitX{ 1.0f, 0.0f, 0.0f };
    const HMM_Vec3 UnitY{ 0.0f, 1.0f, 0.0f };

    static float rx = 0.0f;
    static float ry = 0.0f;
    const float frame_time = (float)sapp_frame_duration();
    rx += 1.0f * frame_time;
    ry += 2.0f * frame_time;

    CameraP camera_persp;
    camera_persp.LookAt(CamPos, Origin);
    HMM_Mat4 model = HMM_Rotate_RH(rx, UnitX) * HMM_Rotate_RH(ry, UnitY);
    camera_persp.mvp = HMM_Mul(camera_persp.mvp, model);

    /* NOTE: the vs_params_t struct has been code-generated by the shader-code-gen */
    sg_range mvp_range = SG_RANGE(camera_persp.mvp);

    switch (curr_drawpass)
    {
        case DrawPassType::DRAWPASS_COLOR:
        {
            Draw(GlobalState.col_drawstate, GlobalState.colcube_geometry, mvp_range);
        } break;
        case DrawPassType::DRAWPASS_SINGLECOLOR:
        {
            Draw(GlobalState.col_drawstate, GlobalState.singlecolorcube, mvp_range);
        } break;
        case DrawPassType::DRAWPASS_TEXTURE:
        {
            Draw(GlobalState.tex_drawstate, GlobalState.texcube_geometry, mvp_range);
        } break;
        default:
        {
            THEPIT_ASSERT(false);
        } break;
    }
}

void thepit::Cleanup()
{
    sg_shutdown();

    delete GlobalState.cube_mesh->geometry;
    delete GlobalState.cube_mesh;
    delete GlobalState.cube_material;

    delete GlobalState.texcube_geometry;
    delete GlobalState.tex_drawstate;
    delete GlobalState.col_drawstate;
}

void thepit::HandleEvent(const sapp_event* Event)
{
    switch (Event->type)
    {
        case SAPP_EVENTTYPE_KEY_DOWN:
        {
            if (0 == Event->key_repeat && SAPP_KEYCODE_SPACE == Event->key_code)
            {
                curr_drawpass = (DrawPassType)(((int)curr_drawpass + 1) % (int)DrawPassType::DRAWPASS_NUM);
            }
        } break;
        default: { } break;
    }
}

void thepit::HandleCmdLine(int argc, char** argv)
{
	global_argc = argc;
	global_argv = argv;
}

const char* thepit::GetProjectDir()
{
    static const char* project_name = "ThePit";
    static const char* project_dir = nullptr;
    static std::string project_dir_str;
    if (!project_dir)
    {
        THEPIT_ASSERT(0 < global_argc);
        project_dir_str = global_argv[0];
        size_t ThePitDir = project_dir_str.find(project_name);
        project_dir_str = project_dir_str.substr(0, ThePitDir + strlen(project_name));
        project_dir = project_dir_str.c_str();
    }
    return project_dir;
}

