#include "Engine.h"
#include "Cube.h"
#include "DrawState.h"
#include "glsl/cube-sapp.glsl.h"

namespace thepit
{
    GlobalState_t GlobalState;
}

void thepit::Init()
{
    sg_desc setup = {};
    setup.environment = sglue_environment();
    setup.logger.func = slog_func;
    sg_setup(&setup);

    // Create cube geometry, material, and mesh
    GeometryT* cube = InitNewCubeColorGeometry();  // Generate cube geometry
    GlobalState.cube_material = InitNewCubeMaterial();  // Initialize the material
    GlobalState.cube_mesh = InitNewMesh(cube, GlobalState.cube_material);  // Initialize mesh

    // Set the initial position of the cube
    GlobalState.cube_mesh->transform.position = { 0.0f, 0.0f, -1.0f }; // (move back slightly)

    GlobalState.pip = GlobalState.cube_mesh->pipeline;
    GlobalState.bind = GlobalState.cube_mesh->bindings;

    GlobalState.texcube_geometry = new MeshDrawT{ InitNewCubeTexGeometry() };
    GlobalState.tex_drawstate = InitNewTexturePipeline();
}

void thepit::Frame()
{
    const HMM_Vec3 Origin{ 0.0f, 0.0f, 0.0f };
    const HMM_Vec3 WorldUp{ 0.0f, 1.0f, 0.0f };
    const HMM_Vec3 CamPos{ 0.0f, 1.5f, 5.0f };
    const HMM_Vec3 UnitX{ 1.0f, 0.0f, 0.0f };
    const HMM_Vec3 UnitY{ 0.0f, 1.0f, 0.0f };

    static float rx = 0.0f;
    static float ry = 0.0f;
    const float frame_time = (float)sapp_frame_duration();
    rx += 1.0f * frame_time;
    ry += 2.0f * frame_time;

    const float aspect_ratio = sapp_widthf() / sapp_heightf();
    const float fov_degrees = 61.5f;

    HMM_Mat4 view_proj = HMM_Perspective_RH_ZO(fov_degrees, aspect_ratio, 0.01f, 10.0f) * HMM_LookAt_RH(CamPos, Origin, WorldUp);
    HMM_Mat4 model = HMM_Rotate_RH(rx, UnitX) * HMM_Rotate_RH(ry, UnitY);

    /* NOTE: the vs_params_t struct has been code-generated by the shader-code-gen */
    vs_params_t vs_params{ HMM_Mul(view_proj, model) };
    sg_range vs_params_r = SG_RANGE(vs_params);

    sg_pass pass = {};
    pass.action.colors[0].load_action = SG_LOADACTION_CLEAR;
    pass.action.colors[0].clear_value = { 0.25f, 0.5f, 0.75f, 1.0f };
    pass.swapchain = sglue_swapchain();

    static bool bTexture = true;
    if (bTexture)
    {
        Draw(GlobalState.tex_drawstate, GlobalState.texcube_geometry, vs_params_r);
    }
    else
    {
        sg_begin_pass(&pass);
        sg_apply_pipeline(GlobalState.pip);
        sg_apply_bindings(&GlobalState.bind);
        sg_apply_uniforms(SG_SHADERSTAGE_VS, SLOT_vs_params, &vs_params_r);
        sg_draw(0, (int)GlobalState.cube_mesh->geometry->element_count, 1);
        sg_end_pass();
        sg_commit();
    }
}

void thepit::Cleanup()
{
	sg_shutdown();

    delete GlobalState.cube_mesh;
    delete GlobalState.cube_material;
}

void thepit::HandleEvent(const sapp_event* Event)
{
}
